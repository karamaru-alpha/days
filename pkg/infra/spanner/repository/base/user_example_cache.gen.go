// Code generated by protoc-gen-days (generator/spanner) . DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package base

import (
	"context"
	"sync"

	"github.com/scylladb/go-set/i64set"
	"github.com/scylladb/go-set/strset"

	"github.com/karamaru-alpha/days/pkg/dcontext"
	"github.com/karamaru-alpha/days/pkg/domain/entity/transaction"
)

type UserExampleSearchResultCache interface {
	Lock()
	Unlock()
	GetByPK(pk *transaction.UserExamplePK) (*transaction.UserExample, SearchResultType)
	GetByPKs(pks transaction.UserExamplePKs) (transaction.UserExampleSlice, SearchResultType)
	GetOriginByPK(pk *transaction.UserExamplePK) (*transaction.UserExample, SearchResultType)
	GetByQueryConditions(queryConditions []*UserExampleQueryCondition) (transaction.UserExampleSlice, SearchResultType)
	SetResult(row *transaction.UserExample)
	SetResults(rows transaction.UserExampleSlice)
	SetAsNotFound(pk *transaction.UserExamplePK)
	AppendQueryConditions(queryConditions []*UserExampleQueryCondition)
	ReplaceWithCache(rows transaction.UserExampleSlice) transaction.UserExampleSlice
	FilterByQueryConditions(queryConditions []*UserExampleQueryCondition) transaction.UserExampleSlice
}

type userExampleSearchResultRow struct {
	searchResultType SearchResultType
	searchResult     *transaction.UserExample
}

type userExampleSearchResultCacheKey struct{}

type userExampleSearchResultCache struct {
	mutex               sync.RWMutex
	origin              map[string]*userExampleSearchResultRow
	updated             map[string]*userExampleSearchResultRow
	queryConditionsList [][]*UserExampleQueryCondition
}

func ExtractUserExampleSearchResultCache(ctx context.Context) UserExampleSearchResultCache {
	qctx := dcontext.ExtractQueryCache(ctx)
	if qctx.Nil() {
		return &userExampleSearchResultCache{}
	}

	cacher, ok := qctx.GetCacher(userExampleSearchResultCacheKey{})
	if !ok {
		cacher = &userExampleSearchResultCache{
			origin:              make(map[string]*userExampleSearchResultRow),
			updated:             make(map[string]*userExampleSearchResultRow),
			queryConditionsList: make([][]*UserExampleQueryCondition, 0),
		}
		qctx.SetCacher(userExampleSearchResultCacheKey{}, cacher)
	}
	return cacher.(*userExampleSearchResultCache)
}

func (src *userExampleSearchResultCache) Lock() {
	src.mutex.Lock()
}

func (src *userExampleSearchResultCache) Unlock() {
	src.mutex.Unlock()
}

func (src *userExampleSearchResultCache) GetByPK(pk *transaction.UserExamplePK) (*transaction.UserExample, SearchResultType) {
	if row, ok := src.updated[pk.Key()]; ok {
		return row.searchResult, row.searchResultType
	}

	resultType := SearchResultTypeNotSearched
	hasCache := src.hasCache([]*UserExampleQueryCondition{
		{
			column:   UserExampleColumnNameUserID,
			operator: ConditionOperatorEq,
			value:    pk.UserID,
		},
		{
			column:   UserExampleColumnNameExample,
			operator: ConditionOperatorEq,
			value:    pk.Example,
		},
	})

	if hasCache {
		resultType = SearchResultTypeNotFound
	}
	return nil, resultType
}

func (src *userExampleSearchResultCache) GetOriginByPK(pk *transaction.UserExamplePK) (*transaction.UserExample, SearchResultType) {
	if row, ok := src.origin[pk.Key()]; ok {
		return row.searchResult, row.searchResultType
	}

	resultType := SearchResultTypeNotSearched
	hasCache := src.hasCache([]*UserExampleQueryCondition{
		{
			column:   "UserID",
			operator: ConditionOperatorEq,
			value:    pk.UserID,
		},
		{
			column:   "Example",
			operator: ConditionOperatorEq,
			value:    pk.Example,
		},
	})

	if hasCache {
		resultType = SearchResultTypeNotFound
	}
	return nil, resultType
}

func (src *userExampleSearchResultCache) GetByPKs(pks transaction.UserExamplePKs) (transaction.UserExampleSlice, SearchResultType) {
	result := make(transaction.UserExampleSlice, 0, len(pks))

	for _, pk := range pks {
		value, resultType := src.GetByPK(pk)
		if resultType == SearchResultTypeNotSearched {
			return nil, SearchResultTypeNotSearched
		}
		if value != nil {
			result = append(result, value)
		}
	}

	if len(result) == 0 {
		return nil, SearchResultTypeNotFound
	}
	return result, SearchResultTypeFound
}

func (src *userExampleSearchResultCache) GetByQueryConditions(queryConditions []*UserExampleQueryCondition) (transaction.UserExampleSlice, SearchResultType) {
	if !src.hasCache(queryConditions) {
		return transaction.UserExampleSlice{}, SearchResultTypeNotSearched
	}

	result := src.FilterByQueryConditions(queryConditions)

	if len(result) == 0 {
		return transaction.UserExampleSlice{}, SearchResultTypeNotFound
	}
	return result, SearchResultTypeFound
}

func (src *userExampleSearchResultCache) SetResult(row *transaction.UserExample) {
	if src.origin == nil {
		return
	}

	key := row.GetPK().Key()

	if _, ok := src.origin[key]; !ok {
		src.origin[key] = &userExampleSearchResultRow{
			searchResultType: SearchResultTypeFound,
			searchResult:     row.FullDeepCopy(),
		}
	}
	src.updated[key] = &userExampleSearchResultRow{
		searchResultType: SearchResultTypeFound,
		searchResult:     row,
	}
}

func (src *userExampleSearchResultCache) SetResults(rows transaction.UserExampleSlice) {
	for _, row := range rows {
		src.SetResult(row)
	}
}

func (src *userExampleSearchResultCache) SetAsNotFound(pk *transaction.UserExamplePK) {
	if src.origin == nil {
		return
	}

	key := pk.Key()

	if _, ok := src.origin[key]; !ok {
		src.origin[key] = &userExampleSearchResultRow{
			searchResultType: SearchResultTypeNotFound,
			searchResult:     nil,
		}
	}
	src.updated[key] = &userExampleSearchResultRow{
		searchResultType: SearchResultTypeNotFound,
		searchResult:     nil,
	}
}

func (src *userExampleSearchResultCache) AppendQueryConditions(queryConditions []*UserExampleQueryCondition) {
	if src.queryConditionsList == nil {
		return
	}

	src.queryConditionsList = append(src.queryConditionsList, queryConditions)
}

func (src *userExampleSearchResultCache) ReplaceWithCache(rows transaction.UserExampleSlice) transaction.UserExampleSlice {
	result := make(transaction.UserExampleSlice, 0, len(rows))

	for _, row := range rows {
		if cache, resultType := src.GetByPK(row.GetPK()); cache != nil && resultType == SearchResultTypeFound {
			result = append(result, cache)
		} else if resultType != SearchResultTypeFound {
			result = append(result, row)
		}
	}

	return result
}

func (src *userExampleSearchResultCache) FilterByQueryConditions(queryConditions []*UserExampleQueryCondition) transaction.UserExampleSlice {
	result := make(transaction.UserExampleSlice, 0)

	for _, row := range src.updated {
		isSatisfy := true
		for _, cond := range queryConditions {
			if !row.isSatisfy(cond) {
				isSatisfy = false
				break
			}
		}
		if isSatisfy && row.searchResult != nil {
			result = append(result, row.searchResult)
		}
	}

	return result
}

func (src *userExampleSearchResultCache) hasCache(queryConditions []*UserExampleQueryCondition) bool {
	for _, sourceQueryConditions := range src.queryConditionsList {
		if containsUserExampleConditions(sourceQueryConditions, queryConditions) {
			return true
		}
	}

	return false
}

func (row *userExampleSearchResultRow) isSatisfy(queryCondition *UserExampleQueryCondition) bool {
	searchResult := row.searchResult
	if searchResult == nil {
		return false
	}

	switch queryCondition.column {
	case UserExampleColumnNameUserID:
		switch queryCondition.operator {
		case ConditionOperatorEq:
			conditionValue := queryCondition.value.(string)
			return conditionValue == searchResult.UserID
		case ConditionOperatorIn:
			conditionValueSet := queryCondition.value.(*strset.Set)
			return conditionValueSet.Has(searchResult.UserID)
		}
	case UserExampleColumnNameExample:
		switch queryCondition.operator {
		case ConditionOperatorEq:
			conditionValue := queryCondition.value.(int64)
			return conditionValue == searchResult.Example
		case ConditionOperatorIn:
			conditionValueSet := queryCondition.value.(*i64set.Set)
			return conditionValueSet.Has(searchResult.Example)
		}
	}

	return false
}

func containsUserExampleConditions(sourceQueryConditions, targetQueryConditions []*UserExampleQueryCondition) bool {
	if len(sourceQueryConditions) > len(targetQueryConditions) {
		return false
	}

	for _, sourceQueryCondition := range sourceQueryConditions {
		var contains bool
		for _, targetQueryCondition := range targetQueryConditions {
			if containsUserExampleCondition(sourceQueryCondition, targetQueryCondition) {
				contains = true
				break
			}
		}
		if !contains {
			return false
		}
	}

	return true
}

func containsUserExampleCondition(sourceQueryCondition, targetQueryCondition *UserExampleQueryCondition) bool {
	if sourceQueryCondition.column != targetQueryCondition.column {
		return false
	}

	switch sourceQueryCondition.column {
	case UserExampleColumnNameUserID:
		switch sourceQueryCondition.operator {
		case ConditionOperatorEq:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValue := sourceQueryCondition.value.(string)
				targetConditionValue := targetQueryCondition.value.(string)
				return sourceConditionValue == targetConditionValue
			case ConditionOperatorIn:
				sourceConditionValue := sourceQueryCondition.value.(string)
				targetQueryConditionValueSet := targetQueryCondition.value.(*strset.Set)
				return targetQueryConditionValueSet.Size() == 1 && targetQueryConditionValueSet.Has(sourceConditionValue)
			}
		case ConditionOperatorIn:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValues := sourceQueryCondition.value.(*strset.Set)
				targetConditionValue := targetQueryCondition.value.(string)
				return sourceConditionValues.Has(targetConditionValue)
			case ConditionOperatorIn:
				sourceConditionValues := sourceQueryCondition.value.(*strset.Set)
				targetQueryConditionValueSet := targetQueryCondition.value.(*strset.Set)
				return targetQueryConditionValueSet.IsSuperset(sourceConditionValues)
			}
		}
	case UserExampleColumnNameExample:
		switch sourceQueryCondition.operator {
		case ConditionOperatorEq:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValue := sourceQueryCondition.value.(int64)
				targetConditionValue := targetQueryCondition.value.(int64)
				return sourceConditionValue == targetConditionValue
			case ConditionOperatorIn:
				sourceConditionValue := sourceQueryCondition.value.(int64)
				targetQueryConditionValueSet := targetQueryCondition.value.(*i64set.Set)
				return targetQueryConditionValueSet.Size() == 1 && targetQueryConditionValueSet.Has(sourceConditionValue)
			}
		case ConditionOperatorIn:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValues := sourceQueryCondition.value.(*i64set.Set)
				targetConditionValue := targetQueryCondition.value.(int64)
				return sourceConditionValues.Has(targetConditionValue)
			case ConditionOperatorIn:
				sourceConditionValues := sourceQueryCondition.value.(*i64set.Set)
				targetQueryConditionValueSet := targetQueryCondition.value.(*i64set.Set)
				return targetQueryConditionValueSet.IsSuperset(sourceConditionValues)
			}
		}
	}

	return false
}
