// Code generated by protoc-gen-days (generator/spanner) . DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package base

import (
	"context"
	"sync"

	"github.com/scylladb/go-set/strset"

	"github.com/karamaru-alpha/days/pkg/dcontext"
	"github.com/karamaru-alpha/days/pkg/domain/entity/transaction"
)

type UserSearchResultCache interface {
	Lock()
	Unlock()
	GetByPK(pk *transaction.UserPK) (*transaction.User, SearchResultType)
	GetByPKs(pks transaction.UserPKs) (transaction.UserSlice, SearchResultType)
	GetOriginByPK(pk *transaction.UserPK) (*transaction.User, SearchResultType)
	GetByQueryConditions(queryConditions []*UserQueryCondition) (transaction.UserSlice, SearchResultType)
	SetResult(row *transaction.User)
	SetResults(rows transaction.UserSlice)
	SetAsNotFound(pk *transaction.UserPK)
	AppendQueryConditions(queryConditions []*UserQueryCondition)
	ReplaceWithCache(rows transaction.UserSlice) transaction.UserSlice
	FilterByQueryConditions(queryConditions []*UserQueryCondition) transaction.UserSlice
}

type userSearchResultRow struct {
	searchResultType SearchResultType
	searchResult     *transaction.User
}

type userSearchResultCacheKey struct{}

type userSearchResultCache struct {
	mutex               sync.RWMutex
	origin              map[string]*userSearchResultRow
	updated             map[string]*userSearchResultRow
	queryConditionsList [][]*UserQueryCondition
}

func ExtractUserSearchResultCache(ctx context.Context) UserSearchResultCache {
	qctx := dcontext.ExtractQueryCache(ctx)
	if qctx.Nil() {
		return &userSearchResultCache{}
	}

	cacher, ok := qctx.GetCacher(userSearchResultCacheKey{})
	if !ok {
		cacher = &userSearchResultCache{
			origin:              make(map[string]*userSearchResultRow),
			updated:             make(map[string]*userSearchResultRow),
			queryConditionsList: make([][]*UserQueryCondition, 0),
		}
		qctx.SetCacher(userSearchResultCacheKey{}, cacher)
	}
	return cacher.(*userSearchResultCache)
}

func (src *userSearchResultCache) Lock() {
	src.mutex.Lock()
}

func (src *userSearchResultCache) Unlock() {
	src.mutex.Unlock()
}

func (src *userSearchResultCache) GetByPK(pk *transaction.UserPK) (*transaction.User, SearchResultType) {
	if row, ok := src.updated[pk.Key()]; ok {
		return row.searchResult, row.searchResultType
	}

	resultType := SearchResultTypeNotSearched
	hasCache := src.hasCache([]*UserQueryCondition{
		{
			column:   UserColumnNameUserID,
			operator: ConditionOperatorEq,
			value:    pk.UserID,
		},
	})

	if hasCache {
		resultType = SearchResultTypeNotFound
	}
	return nil, resultType
}

func (src *userSearchResultCache) GetOriginByPK(pk *transaction.UserPK) (*transaction.User, SearchResultType) {
	if row, ok := src.origin[pk.Key()]; ok {
		return row.searchResult, row.searchResultType
	}

	resultType := SearchResultTypeNotSearched
	hasCache := src.hasCache([]*UserQueryCondition{
		{
			column:   "UserID",
			operator: ConditionOperatorEq,
			value:    pk.UserID,
		},
	})

	if hasCache {
		resultType = SearchResultTypeNotFound
	}
	return nil, resultType
}

func (src *userSearchResultCache) GetByPKs(pks transaction.UserPKs) (transaction.UserSlice, SearchResultType) {
	result := make(transaction.UserSlice, 0, len(pks))

	for _, pk := range pks {
		value, resultType := src.GetByPK(pk)
		if resultType == SearchResultTypeNotSearched {
			return nil, SearchResultTypeNotSearched
		}
		if value != nil {
			result = append(result, value)
		}
	}

	if len(result) == 0 {
		return nil, SearchResultTypeNotFound
	}
	return result, SearchResultTypeFound
}

func (src *userSearchResultCache) GetByQueryConditions(queryConditions []*UserQueryCondition) (transaction.UserSlice, SearchResultType) {
	if !src.hasCache(queryConditions) {
		return transaction.UserSlice{}, SearchResultTypeNotSearched
	}

	result := src.FilterByQueryConditions(queryConditions)

	if len(result) == 0 {
		return transaction.UserSlice{}, SearchResultTypeNotFound
	}
	return result, SearchResultTypeFound
}

func (src *userSearchResultCache) SetResult(row *transaction.User) {
	if src.origin == nil {
		return
	}

	key := row.GetPK().Key()

	if _, ok := src.origin[key]; !ok {
		src.origin[key] = &userSearchResultRow{
			searchResultType: SearchResultTypeFound,
			searchResult:     row.FullDeepCopy(),
		}
	}
	src.updated[key] = &userSearchResultRow{
		searchResultType: SearchResultTypeFound,
		searchResult:     row,
	}
}

func (src *userSearchResultCache) SetResults(rows transaction.UserSlice) {
	for _, row := range rows {
		src.SetResult(row)
	}
}

func (src *userSearchResultCache) SetAsNotFound(pk *transaction.UserPK) {
	if src.origin == nil {
		return
	}

	key := pk.Key()

	if _, ok := src.origin[key]; !ok {
		src.origin[key] = &userSearchResultRow{
			searchResultType: SearchResultTypeNotFound,
			searchResult:     nil,
		}
	}
	src.updated[key] = &userSearchResultRow{
		searchResultType: SearchResultTypeNotFound,
		searchResult:     nil,
	}
}

func (src *userSearchResultCache) AppendQueryConditions(queryConditions []*UserQueryCondition) {
	if src.queryConditionsList == nil {
		return
	}

	src.queryConditionsList = append(src.queryConditionsList, queryConditions)
}

func (src *userSearchResultCache) ReplaceWithCache(rows transaction.UserSlice) transaction.UserSlice {
	result := make(transaction.UserSlice, 0, len(rows))

	for _, row := range rows {
		if cache, resultType := src.GetByPK(row.GetPK()); cache != nil && resultType == SearchResultTypeFound {
			result = append(result, cache)
		} else if resultType != SearchResultTypeFound {
			result = append(result, row)
		}
	}

	return result
}

func (src *userSearchResultCache) FilterByQueryConditions(queryConditions []*UserQueryCondition) transaction.UserSlice {
	result := make(transaction.UserSlice, 0)

	for _, row := range src.updated {
		isSatisfy := true
		for _, cond := range queryConditions {
			if !row.isSatisfy(cond) {
				isSatisfy = false
				break
			}
		}
		if isSatisfy && row.searchResult != nil {
			result = append(result, row.searchResult)
		}
	}

	return result
}

func (src *userSearchResultCache) hasCache(queryConditions []*UserQueryCondition) bool {
	for _, sourceQueryConditions := range src.queryConditionsList {
		if containsUserConditions(sourceQueryConditions, queryConditions) {
			return true
		}
	}

	return false
}

func (row *userSearchResultRow) isSatisfy(queryCondition *UserQueryCondition) bool {
	searchResult := row.searchResult
	if searchResult == nil {
		return false
	}

	switch queryCondition.column {
	case UserColumnNameUserID:
		switch queryCondition.operator {
		case ConditionOperatorEq:
			conditionValue := queryCondition.value.(string)
			return conditionValue == searchResult.UserID
		case ConditionOperatorIn:
			conditionValueSet := queryCondition.value.(*strset.Set)
			return conditionValueSet.Has(searchResult.UserID)
		}
	}

	return false
}

func containsUserConditions(sourceQueryConditions, targetQueryConditions []*UserQueryCondition) bool {
	if len(sourceQueryConditions) > len(targetQueryConditions) {
		return false
	}

	for _, sourceQueryCondition := range sourceQueryConditions {
		var contains bool
		for _, targetQueryCondition := range targetQueryConditions {
			if containsUserCondition(sourceQueryCondition, targetQueryCondition) {
				contains = true
				break
			}
		}
		if !contains {
			return false
		}
	}

	return true
}

func containsUserCondition(sourceQueryCondition, targetQueryCondition *UserQueryCondition) bool {
	if sourceQueryCondition.column != targetQueryCondition.column {
		return false
	}

	switch sourceQueryCondition.column {
	case UserColumnNameUserID:
		switch sourceQueryCondition.operator {
		case ConditionOperatorEq:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValue := sourceQueryCondition.value.(string)
				targetConditionValue := targetQueryCondition.value.(string)
				return sourceConditionValue == targetConditionValue
			case ConditionOperatorIn:
				sourceConditionValue := sourceQueryCondition.value.(string)
				targetQueryConditionValueSet := targetQueryCondition.value.(*strset.Set)
				return targetQueryConditionValueSet.Size() == 1 && targetQueryConditionValueSet.Has(sourceConditionValue)
			}
		case ConditionOperatorIn:
			switch targetQueryCondition.operator {
			case ConditionOperatorEq:
				sourceConditionValues := sourceQueryCondition.value.(*strset.Set)
				targetConditionValue := targetQueryCondition.value.(string)
				return sourceConditionValues.Has(targetConditionValue)
			case ConditionOperatorIn:
				sourceConditionValues := sourceQueryCondition.value.(*strset.Set)
				targetQueryConditionValueSet := targetQueryCondition.value.(*strset.Set)
				return targetQueryConditionValueSet.IsSuperset(sourceConditionValues)
			}
		}
	}

	return false
}
