// Code generated by protoc-gen-days (generator/spanner) . DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package repository

import (
	"context"
	"time"

	"cloud.google.com/go/spanner"
	"github.com/scylladb/go-set/strset"
	"google.golang.org/grpc/codes"

	"github.com/karamaru-alpha/days/pkg/dcontext"
	"github.com/karamaru-alpha/days/pkg/derrors"
	"github.com/karamaru-alpha/days/pkg/domain/database"
	"github.com/karamaru-alpha/days/pkg/domain/entity/transaction"
	repository "github.com/karamaru-alpha/days/pkg/domain/repository/transaction"
	qspanner "github.com/karamaru-alpha/days/pkg/infra/spanner"
	"github.com/karamaru-alpha/days/pkg/infra/spanner/repository/base"
)

type userExampleRepository struct{}

func NewUserExampleRepository() repository.UserExampleRepository {
	return &userExampleRepository{}
}

func (r *userExampleRepository) extractQueryCache(ctx context.Context) (base.UserExampleSearchResultCache, base.UserExampleMutationWaitBuffer) {
	return base.ExtractUserExampleSearchResultCache(ctx), base.ExtractUserExampleMutationWaitBuffer(ctx)
}

func (r *userExampleRepository) LoadByPK(ctx context.Context, tx database.ROTx, pk *transaction.UserExamplePK) (*transaction.UserExample, error) {
	row, err := r.SelectByPK(ctx, tx, pk)
	if err != nil {
		return nil, err
	}
	if row == nil {
		return nil, derrors.New(derrors.InvalidArgument, "record not found").SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"pk":        pk,
		})
	}

	return row, nil
}

func (r *userExampleRepository) LoadByPKs(ctx context.Context, tx database.ROTx, pks transaction.UserExamplePKs) (transaction.UserExampleSlice, error) {
	rows, err := r.SelectByPKs(ctx, tx, pks)
	if err != nil {
		return nil, err
	}

	set := strset.NewWithSize(len(rows))
	for _, row := range rows {
		set.Add(row.GetPK().Key())
	}

	notFoundPKs := make(transaction.UserExamplePKs, 0, len(pks))
	for _, pk := range pks {
		if !set.Has(pk.Key()) {
			notFoundPKs = append(notFoundPKs, pk)
		}
	}
	if len(notFoundPKs) > 0 {
		return nil, derrors.New(derrors.InvalidArgument, "record not found").SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"pks":       notFoundPKs,
		})
	}

	return rows, nil
}

func (r *userExampleRepository) SelectByPK(ctx context.Context, tx database.ROTx, pk *transaction.UserExamplePK) (result *transaction.UserExample, err error) {
	searchResultCache, _ := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()

	if cachedEntity, resultType := searchResultCache.GetByPK(pk); resultType != base.SearchResultTypeNotSearched {
		return cachedEntity, nil
	}

	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	row, err := roTx.ReadRow(ctx, base.UserExampleTableName, spanner.Key(pk.Generate()), base.UserExampleColumnNames)
	if err != nil {
		if spanner.ErrCode(err) == codes.NotFound {
			searchResultCache.SetAsNotFound(pk)
			return nil, nil
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"pk":        pk,
		})
	}

	result, err = r.decodeAllColumns(row)
	if err != nil {
		return nil, err
	}

	searchResultCache.SetResult(result)

	return result, nil
}

func (r *userExampleRepository) SelectByPKs(ctx context.Context, tx database.ROTx, pks transaction.UserExamplePKs) (rows transaction.UserExampleSlice, err error) {
	if len(pks) == 0 {
		return transaction.UserExampleSlice{}, nil
	}

	searchResultCache, _ := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	if cachedEntity, resultType := searchResultCache.GetByPKs(pks); cachedEntity != nil && resultType != base.SearchResultTypeNotSearched {
		return cachedEntity, nil
	}

	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	keySets := make([]spanner.KeySet, 0, len(pks))
	for _, pk := range pks {
		if _, resultType := searchResultCache.GetByPK(pk); resultType != base.SearchResultTypeNotSearched {
			continue
		}
		keySets = append(keySets, spanner.Key(pk.Generate()))
	}
	ri := roTx.Read(ctx, base.UserExampleTableName, spanner.KeySets(keySets...), base.UserExampleColumnNames)
	rows = make(transaction.UserExampleSlice, 0)
	keySet := strset.New()
	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleSlice, 0, ri.RowCount)
			keySet = strset.NewWithSize(int(ri.RowCount))
		}
		result, err := r.decodeAllColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)
		keySet.Add(result.GetPK().Key())
		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"pks":       pks,
		})
	}

	rows = searchResultCache.ReplaceWithCache(rows)
	searchResultCache.SetResults(rows)
	for _, pk := range pks {
		if cachedEntity, resultType := searchResultCache.GetByPK(pk); resultType == base.SearchResultTypeNotSearched {
			searchResultCache.SetAsNotFound(pk)
		} else if !keySet.Has(pk.Key()) && cachedEntity != nil {
			rows = append(rows, cachedEntity)
		}
	}

	return rows, nil
}

func (r *userExampleRepository) SelectAll(ctx context.Context, tx database.ROTx, limit, offset int) (rows transaction.UserExampleSlice, err error) {
	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	sql, params := base.NewUserExampleQueryBuilder().
		SelectAll().
		OrderBy(base.OrderPairs{{Column: base.UserExampleColumnNameUserID, OrderType: base.OrderTypeASC}, {Column: base.UserExampleColumnNameExample, OrderType: base.OrderTypeASC}}).
		Limit(limit).
		Offset(offset).
		GetQuery()
	stmt := spanner.Statement{
		SQL:    sql,
		Params: params,
	}
	ri := roTx.Query(ctx, stmt)

	rows = make(transaction.UserExampleSlice, 0)
	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleSlice, 0, ri.RowCount)
		}
		result, err := r.decodeAllColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)
		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"limit":     limit,
			"offset":    offset,
		})
	}

	return rows, nil
}

func (r *userExampleRepository) SelectByUserID(ctx context.Context, tx database.ROTx, userID string) (rows transaction.UserExampleSlice, err error) {
	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	qb := base.NewUserExampleQueryBuilder().
		SelectAll().
		Where().UserIDEq(userID)

	searchResultCache, _ := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	if cachedEntities, resultType := searchResultCache.GetByQueryConditions(qb.GetQueryConditions()); resultType != base.SearchResultTypeNotSearched {
		return cachedEntities, nil
	}

	sql, params := qb.GetQuery()
	stmt := spanner.Statement{
		SQL:    sql,
		Params: params,
	}
	ri := roTx.Query(ctx, stmt)

	rows = make(transaction.UserExampleSlice, 0)
	keySet := strset.New()
	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleSlice, 0, ri.RowCount)
			keySet = strset.NewWithSize(int(ri.RowCount))
		}
		result, err := r.decodeAllColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)
		keySet.Add(result.GetPK().Key())
		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
		})
	}

	rows = searchResultCache.ReplaceWithCache(rows)
	searchResultCache.SetResults(rows)
	searchResultCache.AppendQueryConditions(qb.GetQueryConditions())

	for _, value := range searchResultCache.FilterByQueryConditions(qb.GetQueryConditions()) {
		if !keySet.Has(value.GetPK().Key()) {
			rows = append(rows, value)
		}
	}

	return rows, nil
}

func (r *userExampleRepository) SelectByUserIDs(ctx context.Context, tx database.ROTx, userIDs []string) (rows transaction.UserExampleSlice, err error) {

	if len(userIDs) == 0 {
		return transaction.UserExampleSlice{}, nil
	}

	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	qb := base.NewUserExampleQueryBuilder().
		SelectAll().
		Where().UserIDIn(userIDs)

	searchResultCache, _ := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	if cachedEntities, resultType := searchResultCache.GetByQueryConditions(qb.GetQueryConditions()); resultType != base.SearchResultTypeNotSearched {
		return cachedEntities, nil
	}

	sql, params := qb.GetQuery()
	stmt := spanner.Statement{
		SQL:    sql,
		Params: params,
	}
	ri := roTx.Query(ctx, stmt)

	rows = make(transaction.UserExampleSlice, 0)
	keySet := strset.New()
	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleSlice, 0, ri.RowCount)
			keySet = strset.NewWithSize(int(ri.RowCount))
		}
		result, err := r.decodeAllColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)
		keySet.Add(result.GetPK().Key())
		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
		})
	}

	rows = searchResultCache.ReplaceWithCache(rows)
	searchResultCache.SetResults(rows)
	searchResultCache.AppendQueryConditions(qb.GetQueryConditions())

	for _, value := range searchResultCache.FilterByQueryConditions(qb.GetQueryConditions()) {
		if !keySet.Has(value.GetPK().Key()) {
			rows = append(rows, value)
		}
	}

	return rows, nil
}

func (r *userExampleRepository) SelectByIdxExampleWithExample(ctx context.Context, tx database.ROTx, example int64) (rows transaction.UserExampleIdxExampleSlice, err error) {
	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	qb := base.NewUserExampleQueryBuilder().
		SelectIdxExample().
		Where().ExampleEq(example)

	sql, params := qb.GetQuery()
	stmt := spanner.Statement{
		SQL:    sql,
		Params: params,
	}
	ri := roTx.Query(ctx, stmt)

	rows = make(transaction.UserExampleIdxExampleSlice, 0)

	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleIdxExampleSlice, 0, ri.RowCount)

		}
		result, err := r.decodeIdxExampleColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)

		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
		})
	}

	return rows, nil
}

func (r *userExampleRepository) SelectByIdxExampleWithExamples(ctx context.Context, tx database.ROTx, examples []int64) (rows transaction.UserExampleIdxExampleSlice, err error) {
	roTx, err := qspanner.ExtractROTx(tx)
	if err != nil {
		return nil, err
	}

	qb := base.NewUserExampleQueryBuilder().
		SelectIdxExample().
		Where().ExampleIn(examples)

	sql, params := qb.GetQuery()
	stmt := spanner.Statement{
		SQL:    sql,
		Params: params,
	}
	ri := roTx.Query(ctx, stmt)

	rows = make(transaction.UserExampleIdxExampleSlice, 0)

	if err := ri.Do(func(row *spanner.Row) error {
		if len(rows) == 0 {
			rows = make(transaction.UserExampleIdxExampleSlice, 0, ri.RowCount)

		}
		result, err := r.decodeIdxExampleColumns(row)
		if err != nil {
			return err
		}
		rows = append(rows, result)

		return nil
	}); err != nil {
		if err, ok := derrors.As(err); ok {
			return nil, err
		}
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
		})
	}

	return rows, nil
}

func (r *userExampleRepository) Insert(ctx context.Context, tx database.RWTx, row *transaction.UserExample) (err error) {
	now := dcontext.Now(ctx)
	row.CreatedTime = now
	row.UpdatedTime = now

	searchResultCache, mutationWaitBuffer := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	mutationWaitBuffer.Lock()
	defer mutationWaitBuffer.Unlock()

	if err := mutationWaitBuffer.MergeOperation(&base.UserExampleMutationWaitBufferRecordOperation{
		Type:           base.OperationTypeInsert,
		PK:             row.GetPK(),
		ColumnValueMap: row.ToKeyValue(),
	}); err != nil {
		return err
	}

	searchResultCache.SetResult(row)

	return nil
}

func (r *userExampleRepository) BulkInsert(ctx context.Context, tx database.RWTx, rows transaction.UserExampleSlice) (err error) {
	if len(rows) == 0 {
		return nil
	}

	now := dcontext.Now(ctx)
	searchResultCache, mutationWaitBuffer := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	mutationWaitBuffer.Lock()
	defer mutationWaitBuffer.Unlock()

	for _, row := range rows {
		row.CreatedTime = now
		row.UpdatedTime = now
		if err := mutationWaitBuffer.MergeOperation(&base.UserExampleMutationWaitBufferRecordOperation{
			Type:           base.OperationTypeInsert,
			PK:             row.GetPK(),
			ColumnValueMap: row.ToKeyValue(),
		}); err != nil {
			return err
		}
	}

	searchResultCache.SetResults(rows)

	return nil
}

func (r *userExampleRepository) Update(ctx context.Context, tx database.RWTx, row *transaction.UserExample) (err error) {
	now := dcontext.Now(ctx)
	row.UpdatedTime = now
	searchResultCache, mutationWaitBuffer := r.extractQueryCache(ctx)

	pk := row.GetPK()
	originRow, resultType := searchResultCache.GetOriginByPK(pk)
	sourceRow := originRow
	if sourceRow == nil {
		sourceRow = pk.ToEntity()
	}
	updatedRow := mutationWaitBuffer.GetLatestEntity(sourceRow)
	var cachedRow *transaction.UserExample
	switch {
	case updatedRow != nil:
		cachedRow = updatedRow
	case originRow != nil:
		cachedRow = originRow
	default:
		switch resultType {
		case base.SearchResultTypeNotSearched:
			return derrors.New(derrors.InvalidArgument, "cannot update record not selected").SetValues(map[string]any{
				"tableName": base.UserExampleTableName,
				"pk":        pk,
			})
		case base.SearchResultTypeNotFound:
			return derrors.New(derrors.InvalidArgument, "cannot update record not found").SetValues(map[string]any{
				"tableName": base.UserExampleTableName,
				"pk":        pk,
			})
		default:
			return derrors.New(derrors.InvalidArgument, "invalid cache").SetValues(map[string]any{
				"tableName": base.UserExampleTableName,
				"pk":        pk,
			})
		}
	}

	if err := mutationWaitBuffer.MergeOperation(&base.UserExampleMutationWaitBufferRecordOperation{
		Type:           base.OperationTypeUpdate,
		PK:             pk,
		ColumnValueMap: r.diffEntity(cachedRow, row),
	}); err != nil {
		return err
	}

	searchResultCache.SetResult(row)

	return nil
}

func (r *userExampleRepository) Save(ctx context.Context, tx database.RWTx, row *transaction.UserExample) error {
	var err error
	if row.CreatedTime.IsZero() {
		err = r.Insert(ctx, tx, row)
	} else {
		err = r.Update(ctx, tx, row)
	}

	return err
}

func (r *userExampleRepository) Delete(ctx context.Context, tx database.RWTx, pk *transaction.UserExamplePK) (err error) {
	searchResultCache, mutationWaitBuffer := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	mutationWaitBuffer.Lock()
	defer mutationWaitBuffer.Unlock()

	switch _, resultType := searchResultCache.GetByPK(pk); resultType {
	case base.SearchResultTypeNotSearched:
		// allow for the implementation using interleaving and to maintain backward compatibility
	case base.SearchResultTypeNotFound:
		// return early because record not found
		return nil
	}

	if err := mutationWaitBuffer.MergeOperation(&base.UserExampleMutationWaitBufferRecordOperation{
		Type: base.OperationTypeDelete,
		PK:   pk,
	}); err != nil {
		return err
	}

	searchResultCache.SetAsNotFound(pk)

	return nil
}

func (r *userExampleRepository) BulkDelete(ctx context.Context, tx database.RWTx, pks transaction.UserExamplePKs) (err error) {
	if len(pks) == 0 {
		return nil
	}

	searchResultCache, mutationWaitBuffer := r.extractQueryCache(ctx)
	searchResultCache.Lock()
	defer searchResultCache.Unlock()
	mutationWaitBuffer.Lock()
	defer mutationWaitBuffer.Unlock()

	for _, pk := range pks {
		switch _, resultType := searchResultCache.GetByPK(pk); resultType {
		case base.SearchResultTypeNotSearched:
			// allow for the implementation using interleaving and to maintain backward compatibility
		case base.SearchResultTypeNotFound:
			// return early because record not found
			continue
		}

		if err := mutationWaitBuffer.MergeOperation(&base.UserExampleMutationWaitBufferRecordOperation{
			Type: base.OperationTypeDelete,
			PK:   pk,
		}); err != nil {
			return err
		}

		searchResultCache.SetAsNotFound(pk)
	}

	return nil
}

func (r *userExampleRepository) decodeAllColumns(row *spanner.Row) (*transaction.UserExample, error) {
	var userID spanner.NullString
	var example spanner.NullInt64
	var createdTime spanner.NullTime
	var updatedTime spanner.NullTime

	if err := row.Columns(
		&userID,
		&example,
		&createdTime,
		&updatedTime,
	); err != nil {
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"key":       "All",
		})
	}

	var result transaction.UserExample
	if !userID.IsNull() {
		result.UserID = userID.StringVal
	}
	if !example.IsNull() {
		result.Example = example.Int64
	}
	if !createdTime.IsNull() {
		result.CreatedTime = createdTime.Time.In(time.Local)
	}
	if !updatedTime.IsNull() {
		result.UpdatedTime = updatedTime.Time.In(time.Local)
	}
	return &result, nil
}

func (r *userExampleRepository) decodeIdxExampleColumns(row *spanner.Row) (*transaction.UserExampleIdxExample, error) {
	var userID spanner.NullString
	var example spanner.NullInt64

	if err := row.Columns(
		&userID,
		&example,
	); err != nil {
		return nil, derrors.Wrap(err, derrors.Internal, err.Error()).SetValues(map[string]any{
			"tableName": base.UserExampleTableName,
			"key":       "IdxExample",
		})
	}

	var result transaction.UserExampleIdxExample
	if !userID.IsNull() {
		result.UserID = userID.StringVal
	}
	if !example.IsNull() {
		result.Example = example.Int64
	}
	return &result, nil
}

func (r *userExampleRepository) diffEntity(source, target *transaction.UserExample) map[string]any {
	result := make(map[string]any, 0)

	if !source.CreatedTime.Equal(target.CreatedTime) {
		result[transaction.UserExampleColumnName_CreatedTime] = target.CreatedTime
	}
	if !source.UpdatedTime.Equal(target.UpdatedTime) {
		result[transaction.UserExampleColumnName_UpdatedTime] = target.UpdatedTime
	}

	return result
}
